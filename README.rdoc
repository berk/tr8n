= Welcome to Tr8n Translation Engine

Tr8n translation engine is a rails engine plugin that provides a framework for crowd-source translations and management of any internationalized text 
throughout any rails based application. The power of the engine comes from its simple and friendly user interface that allows site users 
to rapidly translate the site into hundreds of languages. The flexible and robust rules engine that powers Tr8n allows for any combinations 
of language specific rules in any translatable sentence. Users themselves can provide information on what sentences depend on gender rules, 
number rules or other types of rules supported by the engine. The language specific rules can be registered and managed for any language in 
the advanced user interface. The engine also provides a set of powerful admin tools that allow admins to manage any aspect of the engine; 
enabling and disabling its features and monitoring translation process.

The Tr8n engine itself is based on a very robust and flexible pluggable architecture where rule types and even syntax of the "tr" tokens 
can be configured or extended for any application deployment.

= Installation Instructions

Tr8n is mostly self-contained. The only two plugins it depends on are will_paginate created by Mislav MarohniÄ‡ for results pagination 
and will_filter created by me for filtering results in the admin interface. 

To install the required plugins, run the following commands:

  $ script/plugin install git://github.com/mislav/will_paginate.git
  
  $ script/plugin install git://github.com/berk/will_filter.git
  $ rake will_filter:sync  
  $ rake db:migrate 
  $ cd public; ln -s ../vendor/plugins/will_filter/public/wf wf

To install, configure and initialize Tr8n engine, run the following commands: 

  $ script/plugin install git://github.com/berk/tr8n.git
  $ rake tr8n:sync         
  $ rake db:migrate 
  $ rake tr8n:init
  $ cd public; ln -s ../vendor/plugins/tr8n/public/tr8n tr8n

= Integration Instructions

Now you are ready to integrate tr8n into your application. Tr8n comes with a bunch of default configurations 
that, mostly likely, will be applicable to your application. When you run the "rake tr8n:sync" command the 
configuration files were copied into your application config folder under the tr8n folder. 

The main Tr8n configuration file is located here:

  config/tr8n/config.yml

The content of the file is mostly self-explanatory. The most important parts of the config that you may want to review are under the site_info section.

= Tr8n Notations

The following sections give a quick overview for how to integrate tr8n into your rails application. 
For full details use the Tr8n Integration Guide. 

== Label Internationalization

The function for internationalizing labels has the following signature:

  <%= tr(LABEL, DESCRIPTION = "", TOKENS = {}, OPTIONS = {}) %>

  * LABEL is a required string 
  * DESCRIPTION is an optional, but highly recommended string
  * TOKENS is an optional hash of token values - it is required if tokens are used in the label 
  * OPTIONS is an optional hash of options

The following is the first simplest example of an internationalized phrase:

  <%= tr("Hello World") %>
  
or alternatively:

  <%= "Hello World".translate %>
 
As you might have noticed, the DESCRIPTION is not mandatory, but it should be used in cases when the label alone is not sufficient enough to 
determine the meaning of the sentence being translated. For example, when the translators use the bulk translation mode and look 
at the list of strings, they won't be able to tell what the "Invite" by itself means. In that case DESCRIPTION will be very helpful. 

Tr8n translation engine uses label and description to create a unique key for each phrase. So the description serves two purposes: 
it creates a unique key for each label and it also gives a hint to the translators for the context in which the label is used. For example,
the following two phrases will be registered as two independent entries in a database even though the have the same label, but a different description.
The user will have to translate each one of them separately as they will have different translated labels in other languages.

  <%= tr("Invite", "Link to invite your friends to join the site") %>
  <%= tr("Invite", "An invitation you recieved from your friend") %>

It is important to provide the best possible description for each phrase from the start. Keep in mind that changing a description 
in the future, after it has already been translated, will register a new phrase in the database and invalidate all of its translations.  
On the other hand, labels that are complete sentences may not need a description as they are fully self-contained.

There are a number of other flavors of the "tr" function like trl, trfe, trfn that set default options for various reasons. 
You can read more about them in the Tr8n Integration Guide.

== Tr8n Internationalization Notations

The following is a short summary of the tr8n's internationalization notations.

=== Definition of Tr8n Tokens

It would have been boring if all of the labels in a site were just simple sentences without any dynamic data or decorations. 
Tr8n tokens are there to support the dynamic information in a label. 

Currently there are two major types of tokens defined in the extensible Tr8n syntax: data tokens and decoration tokens.
Data tokens are defined as any strings surrounded by curly brackets inside of a label. So anything of this form 
{TOKEN_NAME} is considered a data token. 

Decoration tokens are defined as any string surrounded by squared brackets inside of a label. So anything of this form 
&#91;TOKEN_NAME: decorated value&#92; is considered a decoration token. 

There are a number of different flavors of data tokens. Below are some of the flavors with some examples. 

=== Data Tokens

There is a number of ways to substitute a data token with a value. Below are some of the main examples.

Simple string substitution:  

  <%= tr("Dear {user}", "Fragment sample", :user => current_user) %>

The to_s function will be applied on the value of the current_user variable and substituted into the {user} token.
  
==== Value substitution:

  <%= tr("Dear {user}", "Fragment sample", :user => [current_user, display_user(current_user)]) %>
  
Notice one important thing that current_user is passed as a first element in the array. 
This is done for gender rules evaluation - i will describe this in the later sections. 
The second value is the actual value we want to subsitute into the {user} token.  
  
==== Value substitution using symbol method call:

  <%= tr("Dear {user}", "Fragment sample", :user => [current_user, :first_name])  %>
  
As in the previous example, first object for rules engine, second is a symbol that represents a method that will be called on 
the object and the result will be placed into the {user} token. 
  
==== Value substitution using symbol method call with parameters:

  <%= tr("Dear {user}", "Fragment sample", :user => [current_user, :some_method, "value"])  %>
  
Same as the above example, but the method can be called with some parameters.
  
==== Value substitution using lambda method call:

  <%= tr("Dear {user}", "Fragment sample", :user => [current_user, lambda{|val| html_for(val)}])  %>

The second parameter can also be a lambda. In that case current_user will be passed as a val into the lambda and the
result of the lambda evaluation will be placed into the {user} token.  
  
==== Value substitution using lambda method call with parameters:

  <%= tr("Dear {user}", "Fragment sample", :user => [current_user, lambda{|val, test| html_for(val, test)}], "test"])  %>

Same as the above, but lambda has some additional parameters.

You may be wondering why we need so many variations. Well, they are all useful, as you will see later.


=== Method Tokens

Method token allows you to call a method on a token itself. It is useful if you have multiple method calls on the same token in one sentence.
Consider the following example:

  <%= tr("Dear {user.first_name} {user.last_name}", "Fragment sample", :user => current_user) %>

Since the substitution is implied in the token definition itself, you don't have to use any of the basic data token substitution forms.

=== Hidden Tokens

Hidden tokens are used primarely for the default language dynamic data substitution that would not make sense in the translated label.
Hidden tokens will not appear as tokens when translator opens the translation dialog. Consider the following examples: 

  <%= tr("{user} changed {_his_her} name", "Fragment sample", :user => current_user, :_his_her => current_user.his_her)  %>
  <%= tr("you have {count} {_messages}", "Fragment sample", :count => NUM, :_messages => "message".pluralize_for(NUM))  %>

In the first cases _his_her will be subsituted in English to the appropriate phrase based on the current_user gender. And in the second case
the correct form of message will be used based on whether the number is 1 or other.

There is a better approach for the above examples, using the Transform tokens.  But there may still be situations when hidden token can be useful. 

=== Transform tokens

Transform tokens are used together with rules defined in the rules engine. Their primary job is to provide shortcuts for rule based tokens in the site native language. Consider the following example:

  <%= tr("{user} changed {user| his, her} name", "Fragment sample", :user => current_user)  %>

Notice that the hidden token has been replaced by the transform token. Keep in mind that {user} token must be registered as a gender based token. Consider another example:  

  <%= tr("You have {count|| message, messages}", "Fragment sample", :count => messages.size)  %>

Notice that, in this case, {count} must be registered as a number based token. When the native language rule is evaluated it will use the singular or plural form of the word "message" based on the value of count.
A single pipe indicates that the comma delimited word(s) that follow it are dependent on the token value, but the token itself should not be displayed. A double pipe indicates that the value of the token should be displayd as well. 
You don't have to provide the plural form of the word if it can be derived from a singular form. So {count|| message} will be good enough and it will be pluralized by the engine automatically.
Every rule has support for a transform token. For example:

  <%= tr("Michael {date| turned, turns, will turn} 33 on {date}", "Fragment sample", :date => some_date)  %>

This is the case when piped token is used for a date token object. And one more example for a list:

  <%= tr("{users|| likes, like} this link", "Fragment sample", :users => [users_list, lambda{|user| user.first_name}])  %>
  
In this case if the users array contains a single element it will use the first form, otherwise it will use the plural form.

=== Decoration tokens

Decoration tokens are used to decorate some text in a label. Consider the following example:

  <%= tr("[link: Click here] to visit our site", "Fragment sample", :link => lambda{|text| link_to(text, url)})  %>

When this label is rendered "Click here" will be turned into a link. Similarly you can do any kind of HTML decorations inside of the label. 
Alternative ways for using decorations are:

  <%= tr("[link: Click here] to visit Google", nil, :link => "<a href='http://www.google.com'>{$0}</a>")  %>

{$0} is the translated value of the link. And another way, using a default decoration:

  <%= tr("[link: Click here] to visit Google", nil, :link => ['http://www.google.com'])  %>

The default decorations are defined in the config/tr8n/tokens/decorations.yml file. The are presented in the following form:

  bold:       "<strong>{$0}</strong>"
  italic:     "<i>{$0}</i>"
  link:       "<a href='{$1}' style='{$2}'>{$0}</a>" 

You can edit the file and add as many of the default decorations as you need. Notice that you do not need to provide token parameters for decorations that only use {$0} token. 
So this would work just fine:

  <%= tr("This is some [bold: very cool] stuff!")  %>

